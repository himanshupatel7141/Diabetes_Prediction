# -*- coding: utf-8 -*-
"""Diabetes_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yd0W2lvEk1DOfIeRuCMFshh2D9kGVYlb
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

dataframe= pd.read_csv("/content/diabetes.csv")
dataframe.head()

dataframe.columns

dataframe.isnull().sum()

dataframe.dtypes

dataframe.head(20)

"""**EDA**"""

dataframe.shape

dataframe.corr()
plt.figure(figsize=(15,15))
sns.heatmap(dataframe.corr(),annot=True)

dataframe.describe()

sns.distplot(dataframe["Pregnancies"])

sns.distplot(dataframe["Glucose"])

sns.distplot(dataframe["BloodPressure"])

sns.distplot(dataframe["SkinThickness"])

sns.distplot(dataframe["Insulin"])

sns.distplot(dataframe["BMI"])

sns.distplot(dataframe["Age"])

sns.distplot(dataframe["Outcome"])

sns.distplot(dataframe["DiabetesPedigreeFunction"])

dataframe.head()

dataframe['Pregnacies']=dataframe['Pregnancies'].replace(0,dataframe["Pregnancies"].median())
dataframe['Insulin'] = dataframe['Insulin'].replace(0, dataframe['Insulin'].median())
dataframe['BloodPressure']=dataframe['BloodPressure'].replace(0,dataframe["BloodPressure"].median())
dataframe['SkinThickness'] = dataframe['SkinThickness'].replace(0, dataframe['SkinThickness'].median())
dataframe['Insulin']=dataframe['Insulin'].replace(0,dataframe["Insulin"].median())
dataframe['BMI'] = dataframe['BMI'].replace(0, dataframe['BMI'].mean())
dataframe['DiabetesPedigreeFunction']=dataframe['DiabetesPedigreeFunction'].replace(0,dataframe["DiabetesPedigreeFunction"].mean())
dataframe['Age'] = dataframe['Age'].replace(0, dataframe['Age'].median())

"""**Outlier Detection and Normaliztion**"""

dataframe.shape

dataframe.columns

X = dataframe.drop(columns='Outcome', axis=1)
y = dataframe['Outcome']

dataframe.columns

fig, ax = plt.subplots(figsize = (15, 15))
sns.boxplot(data = X, ax=ax)
plt.savefig('boxPlot.jpg')

cols = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']
for col in cols:
    Q1 = X[col].quantile(0.25)
    Q3 = X[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    mask = (X[col] >= lower_bound) & (X[col] <= upper_bound)

# Filter dataset to remove outliers
X_outlier_detection = X[mask]
y_outlier_detection = y[mask]

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_outlier_detection)

X_scaled

print(len(X_outlier_detection), len(y_outlier_detection))

fig, ax = plt.subplots(figsize = (15, 15))
sns.boxplot(data = X_scaled, ax=ax)

dataframe.columns

type(X_scaled)

col=['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin','BMI', 'DiabetesPedigreeFunction', 'Age','Pregnacies']

type(X_scaled)

X_scaled=pd.DataFrame(X_scaled,columns=col)
X_scaled.describe()

y_outlier_detection.value_counts()

X_scaled.reset_index(drop=True, inplace=True)
y_outlier_detection.reset_index(drop=True, inplace=True)

q = X_scaled['Insulin'].quantile(.95)
mask = X_scaled['Insulin'] < q
dataNew = X_scaled[mask]
y_outlier_detection = y_outlier_detection[mask]

ig, ax = plt.subplots(figsize = (15, 15))
sns.boxplot(data = dataNew, ax=ax)
plt.savefig('boxPlot.jpg')

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(dataNew, y_outlier_detection, test_size=0.33, random_state=42)

X_train.shape,X_test.shape

print(y_train.value_counts())

from imblearn.over_sampling import SMOTE
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

# Check resampled class distribution
print("\nResampled class distribution:")
print(pd.Series(y_train_resampled).value_counts())

from sklearn.linear_model import LogisticRegression
# Initialize Logistic Regression
classification = LogisticRegression()
# Fit the model to the training data
classification.fit(X_train_resampled, y_train_resampled)

y_predictions = classification.predict(X_test)
print(y_predictions)

from sklearn.metrics import accuracy_score
accuracy_score(y_test, y_predictions)

from sklearn.metrics import classification_report
target_names = ['Non-Diabetic', 'Diabetic']
print(classification_report(y_test, y_predictions, target_names=target_names))

import pickle

import pickle
pickle.dump(classification, open("classification_model.pkl", "wb"))

classification_model = pickle.load(open("classification_model.pkl", "rb"))

classification_model.predict(X_test)

from sklearn.tree import DecisionTreeClassifier
model = DecisionTreeClassifier()

model.fit(X_train_resampled, y_train_resampled)

y_pred = model.predict(X_train_resampled)

from sklearn import tree
plt.figure(figsize=(10, 10))
tree.plot_tree(model, filled=True)

from sklearn.ensemble import RandomForestClassifier
rf = RandomForestClassifier()
rf.fit(X_train_resampled, y_train_resampled)

rf.score(X_test, y_test)

y_predict_rf = rf.predict(X_test)
print(y_predict_rf)

grid_param =  {
    "n_estimators" : [50, 100, 120],
    'criterion' : ['gini', 'entropy'],
    'max_depth' : range(5)
}

from sklearn.model_selection import GridSearchCV
grid_search_rf = GridSearchCV(param_grid=grid_param, cv=10, n_jobs=6, verbose=1, estimator=rf)
grid_search_rf.fit(X_train, y_train)

grid_search_rf.best_params_

rf_new = RandomForestClassifier(n_estimators=120, criterion='entropy', max_depth=4)
rf_new.fit(X_train, y_train)

rf_new.score(X_test, y_test)

